#!/usr/bin/env python3

import rclpy
import math, random, tf2_ros, numpy as np
from rclpy.node import Node
from interfaces_robot import ImageCoord, DepthCoord
from std_msgs.msg import Bool

class Finder(Node):
    def __init__(self, rosNode ):
        # Publisher / Listener
        self.image_listener = rosNode.create_subscription(ImageCoord, '/ImageDepthCoord', self.match_callback, 10)
        self.depth_publisher= rosNode.create_publisher(DepthCoord, '/DepthCoord', 10)
        self.bool_publisher= rosNode.create_publisher(Bool, '/fantome', 10)
        
    def match_callback(self, msg): 
        global template, template2
        image_gray = cv2.cvtColor(msg.image, cv2.COLOR_BGR2GRAY)

        #Chargement du template et ajustement à la taille de l'échantillon trouvé
        down_width = 2*int(msg.rayon)
        down_height = 2*int(msg.rayon)
        down_points = (down_width, down_height)
        template = cv2.resize(template, down_points, interpolation= cv2.INTER_LINEAR)
        template2 = cv2.resize(template2, down_points, interpolation= cv2.INTER_LINEAR)

        #Calcul du matching avec chacun des 2 templates
        res = cv2.matchTemplate(image_gray, template, cv2.TM_CCOEFF_NORMED)
        res2 = cv2.matchTemplate(image_gray, template2, cv2.TM_CCOEFF_NORMED)

        threshold = 0.5
        fantomeMsg = Bool()
        fantome.data = np.any(res>=threshold) or np.any(res2>=threshold)
        self.bool_publisher.publish(fantomeMsg)

def main():
    global template, template2

    # Initialisation du noeud
    rclpy.init()
    node = Node( "match_template" )

    node.declare_parameter('filepath', "./template/template")
    filepath = node.get_parameter('filepath').value

    template = cv2.imread(filepath+'.jpg',0)
    template2 = cv2.imread(filepath+'2.jpg',0)

    # Appel du contrôle
    local= TemplateNode(node)

    # Infinite Loop:
    rclpy.spin( node )

    # Fin du programme
    node.destroy_node()
    rclpy.shutdown()

if __name__=='__main__':
	main()