#!/usr/bin/python3
import rclpy
import math
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from rclpy.node import Node

obstacleDetec = "noScan"
memory = "no"

# Ros Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init()
    node= Node( 'basic_move' )

    # Initialize our control:
    control= StraightCtrl()
    control.initializeRosNode( node )

    # infinite Loop:
    rclpy.spin( node )

    # clean end
    node.destroy_node()
    rclpy.shutdown()

# Ros Node Class:
class StraightCtrl :
    def initializeRosNode(self, rosNode ):
        # Get logger from the node:
        self._logger= rosNode.get_logger()

        # Initialize publisher:
        self._pubVelocity= rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        # Initialize scan callback:
        self._subToScan= rosNode.create_subscription(
            LaserScan, 'scan',
            self.scan_callback, 10
        )

        # Initialize control callback:
        self._timForCtrl= rosNode.create_timer(
            0.05, self.control_callback
        )

    def scan_callback(self, scanMsg ):
        self._logger.info( '> get scan' )

        global obstacleDetec

        obstaclesLeft= []
        obstaclesRight= []
        angle= scanMsg.angle_min
        for aDistance in scanMsg.ranges :
            if(angle<1.0 and angle>0.0) and (0.05 < aDistance and aDistance < 0.25) : #45° à -45° environ
                aPoint= [
                    math.cos(angle) * aDistance,
                    math.sin(angle) * aDistance
                ]
                obstaclesLeft.append(aPoint)
            if(angle<0.0 and angle>-1.0) and (0.05 < aDistance and aDistance < 0.25) : #45° à -45° environ
                aPoint= [
                    math.cos(angle) * aDistance,
                    math.sin(angle) * aDistance
                ]
                obstaclesRight.append(aPoint)
            angle+= scanMsg.angle_increment
        
        if len(obstaclesLeft) == 0 and len(obstaclesRight) == 0:
            obstacleDetec = "no"
        elif len(obstaclesLeft) != 0 and len(obstaclesRight) == 0:
            obstacleDetec = "left"
        elif len(obstaclesLeft) == 0 and len(obstaclesRight) != 0:
            obstacleDetec = "right"
        elif len(obstaclesLeft) != 0 and len(obstaclesRight) != 0:
            obstacleDetec = "both"

    def control_callback(self):
        self._logger.info( '< define control' )
        global obstacleDetec, memory
        velocity = Twist()
        if obstacleDetec == "no":
            velocity.linear.x = 0.2
            velocity.angular.z = 0.0
            memory = "no"
        elif obstacleDetec == "left":
            if(memory=="right" or memory =="both"): 
                velocity.linear.x = 0.0
                velocity.angular.z = 1.0
            else : 
                memory = "left"
                velocity.linear.x = 0.0
                velocity.angular.z = -1.0
        elif obstacleDetec == "right":
            if(memory=="left"): 
                velocity.linear.x = 0.0
                velocity.angular.z = -1.0
            else : 
                memory="right"
                velocity.linear.x = 0.0
                velocity.angular.z = 1.0
        elif obstacleDetec == "both":
            if(memory=="left"): 
                velocity.linear.x = 0.0
                velocity.angular.z = -1.0
            else : 
                memory="both"
                velocity.linear.x = 0.0
                velocity.angular.z = 1.0
        elif obstacleDetec == "noScan":
            velocity.linear.x = 0.0
            velocity.angular.z = 0.0


        self._pubVelocity.publish(velocity)

# Go:
if __name__ == '__main__' :
    #main()